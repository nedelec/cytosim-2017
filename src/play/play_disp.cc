// Cytosim was created by Francois Nedelec. Copyright 2007-2017 EMBL.

#include "sim.h"
#include "modulo.h"
#include "display1.h"
#include "display2.h"
#include "display3.h"
#include "saveimage.h"
#include "filepath.h"
#include "messages.h"

extern Modulo * modulo;

using  glApp::GP;

//------------------------------------------------------------------------------
void Player::initStyle(const int style)
{
    //std::cerr << "Player::initStyle(" << style << ")" << std::endl;

    if ( mDisplay )
    {
        //restore the state of OpenGL
        glPopAttrib();
        delete(mDisplay);
        mDisplay = 0;
    }
    
    //save the current state of OpenGL
    glPushAttrib(GL_ALL_ATTRIB_BITS);
    
    PP.style = style;
    switch ( style )
    {
        default:
        case 1: mDisplay = new Display1(&DP);  break;
        case 2: mDisplay = new Display2(&DP);  break;
        case 3: mDisplay = new Display3(&DP);  break;
    }
    
    // initialize the View used for off-screen rendering
    if ( glApp::views.size() == 1 )
    {
        View & view = glApp::views[0];
        view.reshaped(view.window_size[0], view.window_size[1]);
        view.initGL(GP.depth_test, GP.multisample, GP.depth_clamp);
        view.setModelView();
    }
    
    // initialize all View, that are associated with existing windows:
    for ( unsigned n = 1; n < glApp::views.size(); ++n )
    {
        View & view = glApp::views[n];
        if ( view.window() > 0 )
        {
            glutSetWindow(view.window());
            view.setProjection();
            view.initGL(GP.depth_test, GP.multisample, GP.depth_clamp);
        }
    }
}

//------------------------------------------------------------------------------
#pragma mark -

/**
 Build a message containing the label and the time.
 For an interactive window, it also adds 'live' or the frame index,
 and the force generated by the mouse.
 */
std::string Player::buildMessageL(Simul const& simul)
{
    std::ostringstream oss;

    if ( !GP.label.empty() )
        oss << GP.label << " " << std::setw(8);
    oss << std::setprecision(3) << std::fixed << simul.simTime() << "s";
    
    //display the force exerted by the mouse-controled Single:
    if ( simThread.handle() && simThread.handle()->attached() )
        oss << "\nHandle: " << simThread.handle()->force().norm() << "pN";

    if ( PP.live )
    {
        oss << "\nLive";
        //display ratio number-of-time-step / frame
        if ( PP.period > 1 )
            oss << " " << PP.period;
    }
    else
    {
        if ( simThread.frame() >= 0 )
            oss << "\nFrame " << simThread.frame();
    }

    return oss.str();
}


/**
 This calls simul.report(),
 making sure that the displayed information is identical to what would be printed
 by the corresponding parser command 'write'.
 */
std::string Player::buildMessageR(Simul const& simul)
{
    if ( PP.report.empty() )
        return "";
    
    std::ostringstream oss;
    
    Glossary opt;
    try {
        simul.report0(oss, PP.report, opt);
    }
    catch ( Exception & e )
    {
        return e.what();   
    }
    return oss.str();
}

/**
 This text is normally display in the center of the window
 */
std::string Player::buildMessage(int type)
{
    std::ostringstream oss;
    switch ( type )
    {
        case 0: return "";
        case 1: return "Please, visit www.cytosim.org";
        case 2: help(oss); return oss.str();
        case 3: glApp::help(oss);  return oss.str();
        case 4: writePlayParameters(oss, true); return oss.str();
        case 5: writeDisplayParameters(oss, true); return oss.str();
    }
    return "";
}

//------------------------------------------------------------------------------
#pragma mark Display

void Player::autoTrack(FiberSet const& fibers, View& view, int mode)
{
    Vector G, D, N;
    
    if ( fibers.infoDirection(G, D, N) > REAL_EPSILON )
    {
        D.normalize();
        Vector3 G3(0,0,0), D3(1,0,0), N3(1,0,0);
        G.put(G3);
        D.put(D3);
        N.put(N3);
        
        switch ( mode )
        {
            case 0: break;
            case 1: view.shift_to(G3); break;
            case 2: view.shift_to(G3); view.rotate_to(D3); break;
            case 3: view.shift_to(G3); view.rotate_to(N3); break;
        }
    }
}

/**
 Adjust to see the biggest Space in simul
 */
int Player::autoScale(SpaceSet const& spaces, View& view)
{
    real rad = 0;
    for ( Space const* sp = spaces.first(); sp; sp=sp->next() )
    {
        real r = sp->extension().norm_inf();
        if ( r > rad ) rad = r;
    }
    if ( rad > 0 )
    {
        //std::cerr << "auto_scale " << rad << std::endl;
        view.setScale(rad);
        view.zoom_in(0.97);
        return 1;
    }
    return 0;
}


void Player::prepareDisplay(View& view, Simul const& simul, real mag)
{    
    //----------------- automatic adjustment of viewing area:
    
    if ( view.auto_scale > 0 )
        view.auto_scale -= autoScale(simul.spaces, view);
    
    //----------------- auto-track:
    
    if ( view.track_fibers )
        autoTrack(simul.fibers, view, view.track_fibers);
    
    //----------------- texts:
    
    GP.message_left = buildMessageL(simul);
    GP.message_right = buildMessageR(simul);
    
    //----------------- set pixel size and unit-size:
    /*
     if DP.point_value is set, line-width and point-size were specified in 'real' units,
     and otherwise, they were specified in pixels.
     */
    if ( DP.point_value > 0 )
        mDisplay->setPixelFactors(view.pixelSize()/mag, mag*DP.point_value/view.pixelSize());
    else
        mDisplay->setPixelFactors(view.pixelSize()/mag, mag);

    //----------------- prepare objects:
    
    try {
        mDisplay->prepareForDisplay(simul, dproperties);
    } catch(Exception & e) {
        std::cerr<<"Error in prepareDisplay: " << e.what() << std::endl;
    }
}

#ifdef DISPLAY_INTERACTIONS
extern bool showInteractions, functionKey[];
#endif

//------------------------------------------------------------------------------
void Player::displayCytosim(Simul const& simul)
{
    //std::cerr << "displayCytosim win=" << glutGetWindow() << std::endl;
    
    //----------------- clear pixels:
    
    DP.back_color.clearColor();
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    //----------------- display:

    try {
        
        if ( modulo && DP.tiled )
            mDisplay->displayTiled(simul, DP.tiled);
        else
            mDisplay->display(simul);
        
#ifndef NDEBUG
        gleReportErrors(stderr, "Player::displayCytosim()");
#endif
        
#ifdef DISPLAY_INTERACTIONS
        if ( !functionKey[1] )
        {
            glPushAttrib(GL_LIGHTING_BIT);
            glDisable(GL_LIGHTING);
            Meca tmp;
            showInteractions = 1;
            const_cast<Simul&>(simul).prepare();
            simul.setInteractions(tmp);
            showInteractions = 0;
            glPopAttrib();
            
            gle::gleReportErrors(stderr, "DISPLAY_INTERACTIONS");
        }
#endif
        
    }  catch(Exception & e) {
        std::cerr<<"Error in display: " << e.what() << std::endl;
    }
}


/**
 display is done only if data can be accessed by this thread,
 otherwise display is postponed with a call to postRedisplay()
 */
void Player::displayLive()
{
    //std::cerr << "displayLive win=" << glutGetWindow() << std::endl;
    SimThread::TryLock lck(&simThread);
    if ( 0 == lck.status() )
    {
        // read the "display" parameters if they have changed
        if ( simul.prop->display_fresh )
        {
            try
            {
                Glossary glos(simul.prop->display);
                GP.read(glos);
                View & view = glApp::currentView();
                view.read(glos);
                view.setModelView();
                DP.read(glos);
            }
            catch( Exception & e )
            {
                std::cerr << "Error: " << e.what() << std::endl;
            }
            simul.prop->display_fresh = false;
        }
        
        prepareDisplay(glApp::currentView(), simul);
        displayCytosim(simul);
    }
    else
    {
        glApp::postRedisplay();
    }
}


/**
 This can be used for off-screen rendering.
 */
void Player::displayScene()
{
    //std::cerr << "displayScene win=" << glutGetWindow() << std::endl;
    View & view = glApp::currentView();
    glApp::setDisplay(view);
    prepareDisplay(view, simul);
    displayCytosim(simul);
    glApp::endDisplay(view, false);
    glFlush();
}


//------------------------------------------------------------------------------
#pragma mark Export Image

/**
 Saves to disc pixels currently stored in graphical memory.
 This does not require access to the simulation world.
 */
int Player::saveImage(const char* name, const char* format)
{
    const View& view = glApp::currentView();
    const int W = view.width(), H = view.height();
    
    int err = SaveImage::saveImage(format, name, 0, 0, W, H);
    
    if ( err == 0 )
        Cytosim::MSG("Cytosim: %ix%i image saved in %s\n", W, H, name);
    else
        std::cerr << "Error while creating file `" << name << "'" << std::endl;
    return err;
}


int Player::saveImage(unsigned indx)
{
    char name[1024];
    char const* format = PP.image_format.c_str();
    snprintf(name, sizeof(name), "image%04i.%s", indx, format);
    std::string cwd;
    if ( PP.image_dir.length() )
    {
        cwd = FilePath::get_dir();
        FilePath::change_dir(PP.image_dir);
    }
    int err = saveImage(name, format);
    if ( cwd.length() )
        FilePath::change_dir(cwd);
    return err;
}

//------------------------------------------------------------------------------

void displayMagnified(int mag, void * arg)
{
    Player::displayCytosim(*static_cast<Simul*>(arg));
    gleReportErrors(stderr, "displayPoster");
}


/**
 save an image where the resolution is magnified by a factor \a mag.
 This requires access to the simulation world.
 */
int Player::saveMagnifiedImage(const int mag, const char* name, const char* format)
{
    if ( !SaveImage::supported(format) )
    {
        std::cerr << "Error unsupported image format `" << format << "'"<< std::endl;
        return -1;
    }
    
    View & view = glApp::currentView();
    const int W = view.width(), H = view.height();
    
    SimThread::Lock lck(&simThread);
    
    //std::cerr << "saveMagnifiedImage " << W << "x" << H << " mag=" << mag << std::endl;

    Player::prepareDisplay(view, simul, mag);

    glApp::setDisplay(view);
    
    int err = SaveImage::saveMagnifiedImage(format, name, mag, W, H, displayMagnified, &simul);
    
    if ( err )
    {
        //std::cerr << " ... trying alternative method:" << std::endl;
        err = SaveImage::saveCompositeImage(format, name, mag, W, H, view.pixelSize(), displayMagnified, &simul);
    }
    
    glApp::endDisplay(view, false);
    
    if ( err == 0 )
        Cytosim::MSG("Cytosim saved %ix image `%s'\n", mag, name);
    return err;
}


/**
 save an image where the resolution is magnified by a factor \a mag.
 This requires access to the simulation world.
 */
int Player::saveMagnifiedImage(const int mag, unsigned indx)
{
    char name[1024];
    char const* format = PP.image_format.c_str();
    snprintf(name, sizeof(name), "poster%04i.%s", indx, format);
    std::string cwd;
    if ( PP.image_dir.length() )
    {
        cwd = FilePath::get_dir();
        FilePath::change_dir(PP.image_dir);
    }
    int err = saveMagnifiedImage(mag, name, format);
    if ( cwd.length() )
        FilePath::change_dir(cwd);
    return err;
}

